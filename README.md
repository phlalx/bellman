# Distributed Algorithms simulation

## Nodes

The distributed system is modelled by a set of `Node.t`, identified
globally by their `Global_id.t`. Nodes communicate with their neighbors 
using a local link identified by a `Local_id.t` according to a user-defined
topology.

![alt text](fig/topology.png)

A user of the simulator must implement the `Node` interface which defines the
behavior of the distributed algorithm.

```
val create : num_nodes:int -> Global_id.t -> num_neighbors:int ->
  send: (Message.t * Local_id.t -> unit) -> t

val execute : t -> Levent.t -> unit
```

Upon creation, a node is provided with the total number of nodes on the network,
its global identifier, the number of its neighbors, and a send function that 
it uses to asynchronously send message to its neighbors.

A node must also implement a function  `execute` which is called by the 
*scheduler* when a *local event* is delivered.

Local events are of two types. Meta events are controling events that are used
by the simulator to act on the nodes (e.g. start, failure simulation, 
topology change...). Messages pertain to the algorithm being simulated.
 Messages are delivered over a local link which is known to the receiving node. 
```
type t = 
  | Meta of Mevent.t
  | Protocol of Message.t * Local_id.t
```

## Scheduler 

```
type t

val create : num_nodes:int -> edges: (int * int) list -> t

val start_all_nodes : t -> unit

val schedule : t -> bool
```

The scheduler is initialized with the network topology (number of nodes and
list of edges). It maintains a global queue of *global events* (`Gevent.t`) comprised of the messages sent by the nodes and meta-events generated by the scheduler. It also keeps track of a simulated time: 
 * Messages are delivered randomly within less than a second after emission,
 * Nodes are supposed to execute instantaneously.

Example of use:
```
let () =
  let edges = [ (0,1); (0,2); (1,2) ] in
  let sc = Scheduler.create ~num_nodes:3 ~edges in
  Scheduler.start_all_nodes sc;
  while Scheduler.schedule sc do () done
```

## Bellman-ford

`Node` and `Message` define a distributed version of the bellman-ford algorithm.
Nodes broadcast eachother their *routing table* until a fixpoint is reached.

A routing table contains for each global id, the best known distance to the node
 and the local link to use to send a message to this node.

Example of execution for a 3-element clique.

```
> ./main.byte 
Topology:
0 -> 0-1, 1-2
1 -> 0-0, 1-2
2 -> 0-0, 1-1
---
2 <- *: Start
2 -> 0: [routing = [0: dist 4611686018427387903, route *; 1: dist 4611686018427387903, route *; 2: dist 0, route *]]
2 -> 1: [routing = [0: dist 4611686018427387903, route *; 1: dist 4611686018427387903, route *; 2: dist 0, route *]]
1 <- *: Start
1 -> 0: [routing = [0: dist 4611686018427387903, route *; 1: dist 0, route *; 2: dist 4611686018427387903, route *]]
1 -> 2: [routing = [0: dist 4611686018427387903, route *; 1: dist 0, route *; 2: dist 4611686018427387903, route *]]
0 <- *: Start
0 -> 1: [routing = [0: dist 0, route *; 1: dist 4611686018427387903, route *; 2: dist 4611686018427387903, route *]]
0 -> 2: [routing = [0: dist 0, route *; 1: dist 4611686018427387903, route *; 2: dist 4611686018427387903, route *]]
1 <- 0: [routing = [0: dist 0, route *; 1: dist 4611686018427387903, route *; 2: dist 4611686018427387903, route *]]
1: routing table updated -> [0: dist 1, route 0; 1: dist 0, route *; 2: dist 4611686018427387903, route *]
1 -> 0: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 4611686018427387903, route *]]
1 -> 2: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 4611686018427387903, route *]]
2 <- 1: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 4611686018427387903, route *]]
2: routing table updated -> [0: dist 2, route 1; 1: dist 1, route 1; 2: dist 0, route *]
2 -> 0: [routing = [0: dist 2, route 1; 1: dist 1, route 1; 2: dist 0, route *]]
2 -> 1: [routing = [0: dist 2, route 1; 1: dist 1, route 1; 2: dist 0, route *]]
0 <- 2: [routing = [0: dist 2, route 1; 1: dist 1, route 1; 2: dist 0, route *]]
0: routing table updated -> [0: dist 0, route *; 1: dist 2, route 1; 2: dist 1, route 1]
0 -> 1: [routing = [0: dist 0, route *; 1: dist 2, route 1; 2: dist 1, route 1]]
0 -> 2: [routing = [0: dist 0, route *; 1: dist 2, route 1; 2: dist 1, route 1]]
2 <- 0: [routing = [0: dist 0, route *; 1: dist 2, route 1; 2: dist 1, route 1]]
2: routing table updated -> [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]
2 -> 0: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
2 -> 1: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
1 <- 2: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
1: routing table updated -> [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]
1 -> 0: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
1 -> 2: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
1 <- 0: [routing = [0: dist 0, route *; 1: dist 2, route 1; 2: dist 1, route 1]]
0 <- 2: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
2 <- 1: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
0 <- 1: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
0: routing table updated -> [0: dist 0, route *; 1: dist 1, route 0; 2: dist 1, route 1]
0 -> 1: [routing = [0: dist 0, route *; 1: dist 1, route 0; 2: dist 1, route 1]]
0 -> 2: [routing = [0: dist 0, route *; 1: dist 1, route 0; 2: dist 1, route 1]]
0 <- 1: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
1 <- 2: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
2 <- 0: [routing = [0: dist 0, route *; 1: dist 1, route 0; 2: dist 1, route 1]]
1 <- 2: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
0 <- 1: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
2 <- 0: [routing = [0: dist 0, route *; 1: dist 1, route 0; 2: dist 1, route 1]]
2 <- 1: [routing = [0: dist 1, route 0; 1: dist 0, route *; 2: dist 1, route 1]]
0 <- 2: [routing = [0: dist 1, route 0; 1: dist 1, route 1; 2: dist 0, route *]]
1 <- 0: [routing = [0: dist 0, route *; 1: dist 1, route 0; 2: dist 1, route 1]]
```



